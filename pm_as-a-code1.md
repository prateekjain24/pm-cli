Product: pm-kit — Docs-as-Code for Product Managers

Vision (one breath)

Make PRDs, roadmaps, OKRs, personas, and release notes live in Git, flow through review gates like code, and publish out to Confluence/Notion without PMs juggling flags or copy-paste hell.

Core principles
	•	Local-first, publish-later. Git is the source of truth; wikis are mirrors.
	•	Zero-brain CLI. Defaults > flags. Infer everything from cwd, .pmrc.yaml, and manifest.
	•	Deterministic phases. Only re-run what changed; resume where comments start.
	•	Quality gates. Block merges on ambiguity/TBD/metrics-missing. No “vibes”.
	•	Traceability. Every story maps to an issue; every issue maps back to the PRD line.

Primary users
	•	PM (owner): authors, publishes, syncs traceability.
	•	Design/Eng leads (reviewers): comment + approve gates.
	•	Leaders/CS/Marketing (consumers): read the published mirrors.

Success (first 90 days)
	•	70% of PM docs authored in repo, not wiki.
	•	Median PRD review cycle ≤ 48h (measured by PR open→merge).
	•	90% of merged PRDs have stories auto-synced to issues with back-links.
	•	Release notes generated from commits/PRDs for every tagged release.

⸻

Information architecture (opinionated)

/product/
  prds/<slug>/
    01_problem.md
    02_solution.md
    03_requirements.md
    04_prototype_prompts.md
    05_final_prd.md
    manifest.yaml           # owner, okr, links, published URLs
    .cache/                 # content hashes per phase
  personas/*.md
  okrs/*.yaml
  roadmap/roadmap.yaml
  releases/*.md
.pmrc.yaml                  # org defaults: publisher, space, jira project, gates

.pmrc.yaml (defaults, not flags):

publisher: confluence     # or notion
confluence: { space: PROD, parent_page_id: 12345 }
jira: { project: PROD }
gates: { lint: strict, block_on_tbd: true, block_on_metrics_missing: true }
templates: acme/default@1.0.0


⸻

Phases (minimal commands, smart defaults)

CLI verbs (no flags unless absolutely needed):
pm new · pm run · pm review · pm publish · pm sync · pm release · pm build · pm status

Phase 0 — Setup & Scaffolding

Goal: Project can birth PM artifacts with one command; repo conventions locked.

Creates: /.pmrc.yaml, template pack pinned, CI job for gates.

User stories
	•	As a PM, I can bootstrap once and never think about config again.

Acceptance
	•	Running pm new prd "Feature Name" in a clean repo works on first try.
	•	CI “pm-gates” job runs lint/schema checks on PRs touching /product.

Tasks
	•	Generate .pmrc.yaml with sensible defaults (detect Confluence/Notion via env vars).
	•	Install GitHub Action pm-gates (lint/schema/broken links/glossary).
	•	Template pack loader (locked by version to ensure reproducibility).

Command

pm new project


⸻

Phase 1 — PRD Creation (Repo-first)

Goal: Author a PRD via deterministic phases, no inter-phase chatter.

Creates: /product/prds/<slug>/* and manifest.yaml.

User stories
	•	As a PM, I can create a new PRD from a name and get structured phase docs.
	•	As a PM, I can re-run only the pieces impacted by my edits.

Acceptance
	•	pm run generates 5 files with required sections; no TBD/“easy/simple” terms.
	•	.cache shows hashes; a second pm run is a no-op if nothing changed.

Tasks
	•	Orchestrator with DAG: P1→P2→P3→P4→P5 (final assembly).
	•	Hash inputs: prior phase outputs + template version + orchestrator version.
	•	Strict section validator; ambiguity dictionary.

Commands

pm new prd "Connect Session Replay to Funnel Analysis"
pm run

Defaults (no flags)
	•	slug inferred from name.
	•	Owner inferred from git user/email.
	•	OKR suggested from nearest /product/okrs/*.yaml objective tags.

⸻

Phase 2 — Collaboration & Quality Gates

Goal: Treat doc PRs like code: lint, schema, broken-link, glossary, required reviewers.

Creates: PR Template, CODEOWNERS, Gate config; inline annotations on PR.

User stories
	•	As a reviewer, I see pass/fail gates and actionable fix suggestions inline.
	•	As a PM, the PR blocks if metrics are not measurable or personas missing.

Acceptance
	•	PRs fail on TBD/ambiguous terms, missing metrics, or orphan personas.
	•	Required reviewers (Design/Eng) enforced via CODEOWNERS.

Tasks
	•	Lint rules: ambiguity, measurable metric formats, persona cross-refs, section completeness.
	•	Reviewdog annotations in PR.
	•	CODEOWNERS autogenerated for /product/**.

Command

pm status   # local dry-run of gates before opening PR


⸻

Phase 3 — Review Mode (Comment-Driven Regen)

Goal: Pull external comments (Confluence/Notion), re-run from earliest impacted phase, push back.

Creates: Updated phase files + manifest.yaml review log.

User stories
	•	As a PM, I drop a wiki URL and the tool fixes from the earliest commented phase onward.
	•	As a PM, I don’t fiddle flags; it figures out scope.

Acceptance
	•	Comments map to phases via page titles/anchors.
	•	pm review <url> regenerates from earliest phase with comments → pm publish mirrors back.

Tasks
	•	Confluence/Notion adapters: fetch parent & children, include comments.
	•	Heuristic & anchor-based phase mapping.
	•	Deterministic regen window: earliest..end.

Commands

pm review https://confluence/.../PRD-Session-Replay
pm publish


⸻

Phase 4 — Traceability (Stories ⇄ Issues)

Goal: One command creates/updates issues from PRD stories; PRD shows live status checkboxes.

Creates: GitHub/Jira issues with deep links back to PRD anchors; status injector.

User stories
	•	As a PM, my PRD’s user stories become tracked issues automatically.
	•	As a PM, I see checkboxes in the PRD update as issues move.

Acceptance
	•	Idempotent upsert: re-running doesn’t duplicate.
	•	Every story in 03_requirements.md has an issue link + back-link.

Tasks
	•	Story parser (front-matter IDs, acceptance criteria).
	•	GitHub/Jira adapters + mapping file stored in manifest.yaml.
	•	Status poller Action to refresh PRD on push/cron.

Commands

pm sync issues
pm sync status


⸻

Phase 5 — Planning Data (Roadmap & OKRs as YAML)

Goal: Roadmap/OKRs live as structured data and render to pretty docs.

Creates: roadmap.yaml, okrs.yaml + generated roadmap.md.

User stories
	•	As a PM, I edit roadmap/OKRs in YAML and publish human-friendly Markdown/Gantt.
	•	As a leader, I filter by quarter, OKR, persona.

Acceptance
	•	Schema-validated; build fails on invalid enum/refs.
	•	Links to PRDs & issues resolve.

Tasks
	•	YAML schemas + renderer (Mermaid/Gantt optional).
	•	Filters (--team, --quarter, --okr) available on build (defaults from cwd context).

Commands

pm build roadmap
pm build okrs


⸻

Phase 6 — Publish & Distribute

Goal: Mirror repo docs to Confluence/Notion as a tidy tree with stable URLs.

Creates: Pages in destination, cross-page links, breadcrumb to repo.

User stories
	•	As a PM, I publish once and everything lands in the right space/parent, with links home.

Acceptance
	•	Publish is idempotent; content hashes prevent unnecessary updates.
	•	Final output: a single summary message with page links (nothing else).

Tasks
	•	Publisher adapters with mapping from local files → page titles.
	•	Hash-based skip; soft-delete or archive behavior for removed files.

Commands

pm publish


⸻

Phase 7 — Release Notes Automation

Goal: Draft release notes from merged PRs/issues since last tag, enriched by PRD “Why it matters”.

Creates: /product/releases/<date>-vX.Y.md + changelog index.

User stories
	•	As a PM, I run one command and get categorized, human-grade notes I lightly edit.

Acceptance
	•	Sections: New, Improvements, Fixes, Breaking; each has links + “Impact” line.
	•	Internal vs external template modes supported by .pmrc.yaml.

Tasks
	•	Harvest PRs/issues by label since last tag.
	•	Summarize; inject PRD impact text when story link exists.
	•	Generate changelog index page.

Commands

pm release draft

(Default scope inferred from repo tags; override only if needed.)

⸻

Phase 8 — Handoff to Eng (Spec-Kit Bridge)

Goal: Translate PRD into Eng-spec/plan/tasks in the code repo with links both ways.

Creates: PR in eng repo with spec/plan/tasks referencing PRD anchors.

User stories
	•	As a PM, I kick off engineering with a ready-to-review spec and task skeleton.

Acceptance
	•	Tasks carry story IDs; contract tests and non-goals preserved.
	•	PR description contains PRD links by section.

Tasks
	•	Repo handshake + PR creation.
	•	Transform requirements → Spec Kit inputs.
	•	Bidirectional link injectors.

Commands

pm handoff

(Target repo default from .pmrc.yaml; only prompt if ambiguous.)

⸻

Phase 9 — Enterprise & Packs

Goal: RBAC, audit, template packs. Teams can install industries’ packs without fork.

Creates: Role matrix, audit trail, pm pack registry.

User stories
	•	As a PM in regulated space, I install a fintech pack and get extra gates/sections.

Acceptance
	•	Audit export for a date range.
	•	Pack version pinned in manifest; reproducible outputs.

Tasks
	•	SSO/RBAC hooks (enforced via CI).
	•	Pack manifest + loader; example packs (B2C, B2B, Fintech).
	•	Audit CLI export.

Commands

pm pack add org/fintech@1.2.0
pm audit export --since 2025-01-01


⸻

Minimal CLI—how flags get avoided
	•	Context from cwd: the subfolder under /product/prds/<slug> sets the target PRD.
	•	Publisher from .pmrc.yaml: no --dest unless you’re overriding per-run.
	•	Scope inference: pm run uses hashes; pm review <url> computes regen window; pm release draft uses last Git tag.
	•	Identity: owner from git config; teams from CODEOWNERS.
	•	OKR linkage: nearest OKR file by quarter; prompt only if multiple candidates.

⸻

Risks & Mitigations (no sugar-coating)
	•	Confluence/Notion API quirks → Mitigate: idempotent publisher, exponential backoff, dry-run.
	•	PMs skipping gates → Mitigate: block merges on high-severity, but allow override with justification tag.
	•	Template sprawl → Mitigate: pack registry with owners, version pinning, deprecation policy.
	•	Jira/GitHub drift → Mitigate: idempotent upserts keyed by story IDs; nightly reconcile.

⸻

Near-term backlog (implementation-ready)
	•	Scaffold: pm new project, pm new prd "<name>"
	•	Orchestrator + hashes + 5 phase templates
	•	Gates: lint/schema/link/glossary; PR annotations
	•	Confluence publisher (idempotent, tree mapping)
	•	Review mode: comment ingestion + regen window
	•	Traceability: pm sync issues, status injector
	•	Roadmap/OKR schema + builders
	•	Release notes generator
	•	Spec-Kit bridge pm handoff

⸻

If you want, I’ll turn this into a repo structure + first-pass templates (PRD, personas, roadmap, OKR) and wire up pm new, pm run, pm publish, pm review, and pm release draft as the MVP path.